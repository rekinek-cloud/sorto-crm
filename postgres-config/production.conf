# PostgreSQL PRODUCTION Optimization for 7.6GB RAM / 4 CPU Server
# Heavily optimized for CRM-GTD Smart application

# Network Configuration
listen_addresses = '*'                    # Listen on all interfaces
port = 5432

# Memory Configuration - AGGRESSIVE OPTIMIZATION
shared_buffers = 768MB                    # 1GB container = 75% for shared buffers
effective_cache_size = 2048MB             # Total memory available for caching
work_mem = 16MB                           # Per-query working memory (increased)
maintenance_work_mem = 192MB              # Maintenance operations (3x larger)
temp_buffers = 64MB                       # Temporary table buffers (2x larger)
wal_buffers = 32MB                        # WAL buffer size (2x larger)

# Connection Settings - OPTIMIZED
max_connections = 25                      # Reduced for better performance
idle_in_transaction_session_timeout = 180000  # 3 minutes (tighter)
tcp_keepalives_idle = 300                 # 5 minutes
tcp_keepalives_interval = 30              # 30 seconds
tcp_keepalives_count = 3                  # 3 retries

# Performance Tuning - PRODUCTION READY
checkpoint_completion_target = 0.9        # Spread checkpoints
checkpoint_timeout = 5min                 # More frequent checkpoints
max_wal_size = 1GB                        # Larger WAL size
min_wal_size = 128MB                      # Larger minimum WAL
wal_compression = on                      # Enable WAL compression
wal_init_zero = off                       # Faster on copy-on-write filesystems
wal_recycle = off                         # Faster on copy-on-write filesystems

# Query Planning - SSD OPTIMIZED
random_page_cost = 1.0                    # SSD-optimized (lower = better)
effective_io_concurrency = 300            # High concurrent I/O for SSDs
seq_page_cost = 1.0                       # Sequential read cost
cpu_tuple_cost = 0.01                     # CPU processing cost
cpu_index_tuple_cost = 0.005              # Index processing cost
cpu_operator_cost = 0.0025                # Operator cost

# Parallel Query - FULL CPU UTILIZATION
max_worker_processes = 4                  # Match CPU cores
max_parallel_workers_per_gather = 2       # Parallel workers per query
max_parallel_workers = 4                  # Total parallel workers
max_parallel_maintenance_workers = 2      # Maintenance parallel workers
parallel_tuple_cost = 0.1                 # Cost of transferring tuples
parallel_setup_cost = 1000.0             # Cost of setting up parallel workers

# Statistics and Logging - PRODUCTION
shared_preload_libraries = 'pg_stat_statements'
track_activities = on
track_counts = on
track_io_timing = on
track_functions = all
log_min_duration_statement = 500          # Log slow queries (500ms+)
log_checkpoints = on
log_connections = off                     # Reduce log noise
log_disconnections = off                  # Reduce log noise
log_lock_waits = on
log_temp_files = 10MB                     # Log large temp files
log_autovacuum_min_duration = 1000        # Log long autovacuums

# Vacuum and Analyze - AGGRESSIVE
autovacuum = on
autovacuum_max_workers = 3                # More autovacuum workers
autovacuum_naptime = 15s                  # More frequent autovacuum
autovacuum_vacuum_scale_factor = 0.05     # Vacuum when 5% changed (more aggressive)
autovacuum_analyze_scale_factor = 0.02    # Analyze when 2% changed (more aggressive)
autovacuum_vacuum_cost_delay = 10ms       # Faster vacuum
autovacuum_vacuum_cost_limit = 1000       # Higher vacuum cost limit

# Background Writer - OPTIMIZED
bgwriter_delay = 100ms                    # Faster background writer
bgwriter_lru_maxpages = 200              # More pages per round
bgwriter_lru_multiplier = 4.0            # Higher multiplier
bgwriter_flush_after = 512kB             # Flush after 512KB

# Archive and Replication
archive_mode = off                        # No archiving for development
wal_level = replica                       # Standard WAL level

# Lock Management - AGGRESSIVE
deadlock_timeout = 500ms                  # Faster deadlock detection
lock_timeout = 10s                        # Shorter lock timeout
statement_timeout = 60s                   # Query timeout (1 minute)

# Client Connection Defaults
default_transaction_isolation = 'read committed'
timezone = 'UTC'
lc_messages = 'en_US.utf8'
lc_monetary = 'en_US.utf8'
lc_numeric = 'en_US.utf8'
lc_time = 'en_US.utf8'
default_text_search_config = 'pg_catalog.english'

# JIT Compilation - ENABLE FOR COMPLEX QUERIES
jit = on
jit_above_cost = 100000
jit_inline_above_cost = 500000
jit_optimize_above_cost = 500000

# Additional Performance Settings
synchronous_commit = off                  # Async commit for better performance
commit_delay = 100                        # Delay before commit (microseconds)
commit_siblings = 5                       # Min concurrent transactions for delay
fsync = on                                # Keep data safety
full_page_writes = on                     # Required for crash safety

# Huge Pages Support (if available)
huge_pages = try                          # Try to use huge pages

# Connection Pooling Support
max_pred_locks_per_transaction = 64
max_locks_per_transaction = 64